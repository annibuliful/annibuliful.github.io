<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:media="http://search.yahoo.com/mrss/"><channel><title><![CDATA[lagmanzaza]]></title><description><![CDATA[A stupid web developer]]></description><link>https://lagmanzaza.github.io//</link><image><url>https://lagmanzaza.github.io//favicon.png</url><title>lagmanzaza</title><link>https://lagmanzaza.github.io//</link></image><generator>Ghost 3.2</generator><lastBuildDate>Tue, 31 Dec 2019 17:29:51 GMT</lastBuildDate><atom:link href="https://lagmanzaza.github.io//rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title><![CDATA[NodeJS Event Emitter]]></title><description><![CDATA[<p>วันนี้เราจะได้รู้กันว่าตัว NodeJS คืออะไร ดียังไง เริ่มได้~~~</p><h4 id="node-event">Node Event ?</h4><p>ด้วยความที่ว่า NodeJS เองทำงานเป็นแบบ event-driven architecture หรือเรียกแบบไทยๆว่าการขับเคลื่อนทุกอย่างด้วย Event มาถึงตรงนี้ทุกคนคงจะงงว่าแล้วตัว event-driven คืออะไร</p><figure class="kg-card kg-image-card"><img src="https://i.imgur.com/yZjiHQy.jpg" class="kg-image"></figure><p>รูปนี้ทุ</p>]]></description><link>https://lagmanzaza.github.io//nodejs-event-emitter/</link><guid isPermaLink="false">5dac2e4cc479810291b1a10a</guid><dc:creator><![CDATA[tar jarupong]]></dc:creator><pubDate>Sun, 20 Oct 2019 09:54:53 GMT</pubDate><media:content url="https://lagmanzaza.github.io//content/images/2019/10/7oG5ce7.png" medium="image"/><content:encoded><![CDATA[<img src="https://lagmanzaza.github.io//content/images/2019/10/7oG5ce7.png" alt="NodeJS Event Emitter"><p>วันนี้เราจะได้รู้กันว่าตัว NodeJS คืออะไร ดียังไง เริ่มได้~~~</p><h4 id="node-event">Node Event ?</h4><p>ด้วยความที่ว่า NodeJS เองทำงานเป็นแบบ event-driven architecture หรือเรียกแบบไทยๆว่าการขับเคลื่อนทุกอย่างด้วย Event มาถึงตรงนี้ทุกคนคงจะงงว่าแล้วตัว event-driven คืออะไร</p><figure class="kg-card kg-image-card"><img src="https://i.imgur.com/yZjiHQy.jpg" class="kg-image" alt="NodeJS Event Emitter"></figure><p>รูปนี้ทุกคนคงเข้าใจ event driven ทุกคนจะเห็นว่ามันคือ Observer design pattern นั้นเองนะครับซึ่งตัว Observer pattern เองเป็นฐานในการทำ event driven ผมขอไม่ลงลึกเรื่อง Observer pattern ง่ายๆก็คือ Observer pattern เอาไว้สำหรับสังเกตุการเปลี่ยนแปลงข้อมูลว่าเปลี่ยนแปลงไปยังไงบ้างนั้นเองครับ </p><h4 id="node-event-">Node Event ใช้งานยังไง ?</h4><p>มาเริ่มใช้ Event emitter กันเลยครับผมขอวาดภาพว่าเราจะทำ service อะไรด้วย Event Emitter นะครับ</p><figure class="kg-card kg-image-card"><img src="https://i.imgur.com/OECu3Yh.png" class="kg-image" alt="NodeJS Event Emitter"></figure><p>ผมจะลองเขียนตามนี้นะครับ เริ่ม~~~<br><br><strong>#1 ทำการสร้าง require และสร้าง event ตัวนึง</strong></p><pre><code>  const EventEmitter = require('events');
  const myService = new EventEmitter();
</code></pre><p><br><strong>#2 สร้างตัว emit data</strong></p><pre><code>  myService.emit('registration',{
    name: "Tar",
    email: "Tar@email.com"
  })

</code></pre><p>ต้องอธิบายก่อนว่าตัว registration คือชื่อ event ครับส่วนตัว object คือข้อมูลที่เราจะส่งผ่านตัว regitration event</p><p><br><strong>#3 สร้างตัว listener สำหรับ email &amp; admin</strong></p><pre><code>  // ใครยังไม่เคยใช้ =&gt; หรือ arrow function ผมมี ref ไว้ข้างล่างครับ
  // email service
  myService.on('registration', (userData) =&gt; {
    console.log(`ส่ง email ไปหาคุณ ${userData.name} ไปที่ ${userData.email}`)
  })
  
  // admin service
  myService.on('registration', (userData)=&gt;{
    console.log(`เจ้านายครับมีลูกค้าสมัครสมาชิก คุณ ${userData.name}$`)
  })

</code></pre><p><br><strong>#4 โค๊ดเต็มๆตามนี้เลยครับ</strong></p><pre><code>  const EventEmitter = require('events');
  const myService = new EventEmitter();
  
  myService.emit('registration',{
    name: "Tar",
    email: "Tar@email.com"
  })
  
  myService.on('registration', (userData) =&gt; {
    console.log(`ส่ง email ไปหาคุณ ${userData.name} ไปที่ ${userData.email}`)
  })
  

  myService.on('registration', (userData)=&gt;{
    console.log(`เจ้านายครับมีลูกค้าสมัครสมาชิก คุณ ${userData.name}$`)
  })

</code></pre><figure class="kg-card kg-image-card"><img src="https://lagmanzaza.github.io//content/images/2019/10/i7sXG6v.png" class="kg-image" alt="NodeJS Event Emitter"></figure><p><br>ก็จบกันไปแล้วนะครับสำหรับ NodeJS Event Emitter แบบพื้นฐานมาก!!!! ผมก็หวังว่าผู้อ่านจะเข้าใจการทำงานและการเขียน Event Emitter นะครับผม วันนี้ผมต้าขอตัวลาไปก่อนชะแว๊บ~~~</p><p>Ref:</p><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions">Arrow functions</a></p><p><a href="https://en.wikipedia.org/wiki/Event-driven_architecture">Event-driven architecture</a></p><p><a href="https://en.wikipedia.org/wiki/Observer_pattern">Observer pattern</a></p><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals">Template literals</a></p>]]></content:encoded></item><item><title><![CDATA[Event-loop แบบพื้นฐานมากกกกก #2]]></title><description><![CDATA[<p>หลังจากที่ผมอธิบาย concept แบบคร่าวๆไปในครั้งที่แล้ว วันนี้เราจะลงลึกไประดับนึงครับ มาเริ่มกันเลยดีกว่า แต่ก่อนอื่นเลยที่เราจะมาทำความเข้าใจเรื่อง Event-loop มาคุยเรื่อง Reactor pattern กันก่อนนะครับ</p><p><br></p><h4 id="reactor-pattern">Reactor Pattern</h4><p>มันคืออะไรกันนะ มันก็คือ pattern</p>]]></description><link>https://lagmanzaza.github.io//event-loop-2/</link><guid isPermaLink="false">5dac152a79778f6fa0d0bea5</guid><category><![CDATA[NodeJS]]></category><dc:creator><![CDATA[tar jarupong]]></dc:creator><pubDate>Sun, 20 Oct 2019 08:05:58 GMT</pubDate><media:content url="https://lagmanzaza.github.io//content/images/2019/10/WlaBgFV.png" medium="image"/><content:encoded><![CDATA[<img src="https://lagmanzaza.github.io//content/images/2019/10/WlaBgFV.png" alt="Event-loop แบบพื้นฐานมากกกกก #2"><p>หลังจากที่ผมอธิบาย concept แบบคร่าวๆไปในครั้งที่แล้ว วันนี้เราจะลงลึกไประดับนึงครับ มาเริ่มกันเลยดีกว่า แต่ก่อนอื่นเลยที่เราจะมาทำความเข้าใจเรื่อง Event-loop มาคุยเรื่อง Reactor pattern กันก่อนนะครับ</p><p><br></p><h4 id="reactor-pattern">Reactor Pattern</h4><p>มันคืออะไรกันนะ มันก็คือ pattern ตัวนึงที่เข้าใจจัดการ event-driven architecture โดยตัวมันเนี๊ยจะทำการ พูดง่ายๆก็คือ Reactor Pattern ทำหน้าที่จัดการ process ที่ใช้เวลานานๆไปเป็น asynchronouse ครับ แล้วส่งกลับมาเป็น callback อย่างที่เรารู้จักกันนี้เอง</p><p>โดยโครงสร้างของมันจะประกอบด้วย 4 ตัวหลักตามนี้ครับ</p><ol><li>Resouce =&gt; ก็ตามชื่อเลยครับมันคือ resource for input &amp; output</li><li>Synchronous Event Demultiplexer =&gt; มันกับตัวแจ้งเตือนว่าทำงานเกี่ยวกับ I/O เสร็จแล้วส่งต่อไปที่ Event queue</li><li>Event Queue =&gt; คือช่องที่เก็บ process ที่ต่อคิวกันรอกันอยู่</li><li>Dispatcher =&gt; คือเอาต้า process จาก Event queue มาทำงานแล้วส่งกลับไป</li></ol><p>เรียบร้อยแล้วครับสำหรับพื้นฐาน ของ Reactor Pattern เรามาเข้าเรื่อง Event-loop แบบจริงจังกันครับ มาลุยกัน~~~</p><p><br></p><h4 id="event-loop">Event-loop</h4><p>ในที่สุดก็เข้าเรื่องพี่ loop สักที ผมขอเริ่มต้นที่รูปภาพแรกก็เลยครับ</p><figure class="kg-card kg-image-card"><img src="https://i.imgur.com/GSBai6R.png" class="kg-image" alt="Event-loop แบบพื้นฐานมากกกกก #2"></figure><p>จะเห็นว่ามี 6 ขั้นตอนหลักๆ ผมจะเริ่มอธิบายเลยนะครับ เย้~</p><ol><li>Application =&gt; จะทำการสร้าง request หรือ process เพื่อส่งต่อไปให้ Event Demultiplexer การทำงานในส่วนนี้เป็นแบบ Non-Blocking เพื่อทำงานส่งต่อไปที่ Event Demultiplexer</li><li>Event Demultiplxer =&gt; เป็นจุดที่ทำงาน เกี่ยวกับ I/O ล้วนๆ เช่น อ่านไฟล์ เขียนไฟล์ เป็นต้น แล้วส่งต่อไปที่ Event queue</li><li>Event queue =&gt; เป็นตัวเก็บ process ที่จะเรียกไปใช้งานผ่านเจ้า Even loop</li><li>Event loop =&gt; จะคอยเช็คไปเรื่อยๆว่ามี process ค้างอยู่ใน Event queue รึเปล่าแล้ว ถ้ามีก็เอามาทำงานให้มันเสร็จจะได้ส่งกลับไป</li><li>Handler =&gt; หลังจากที่ process นั้นๆทำงานเสร็จแล้วก็ส่งกลับมาว่า ฉันทำเสร็จแล้วน๊าาาา ไปทำ queue ต่อไปได้เลยเน้อ ในกรณีที่มี request ใหม่เข้ามาจะถูกถึงไปยัง ข้อ 1 แล้วทำตามขั้นตอนต่อไป</li><li>Event loop ก็จะวนกลับไปทำงานในข้อหนึ่งใหม่ แล้วก็ทำอย่างนี้ไปเรื่อยๆ</li></ol><p>ในที่สุดผมก็เล่าเรื่อง Event loop เสร็จสักที แต่เดี๋ยวก่อนครับ การทำแบบนั้นมันคือแบบ Non-Blocking I/O แล้วถ้าเป็น Blocking I/O ล่ะจะทำยังไงดี มันก็จะเป็นสิ่งที่ผมพูดต่อจากนี้ครับ อย่าพึ่งเบื่อกันไปก่อนนะครับ จะจบแล้ว มาเริ่มเรื่องสุดท้ายของบทความนี้กัน</p><p><strong>Thread pool</strong></p><p>เรามาพูดต่อให้ละเอียดขึ้นดีกว่าครับด้วยภาพนี้เลยครับ</p><figure class="kg-card kg-image-card"><img src="https://i.imgur.com/WlaBgFV.png" class="kg-image" alt="Event-loop แบบพื้นฐานมากกกกก #2"></figure><p>หลังจากที่ทุกคนเข้าใจการทำงานของ event loop แล้วมาพูดถึงเรื่อง thread pool กันครับ มาเข้าสู่เนื้อหาอันชวนปวดหัวกัน</p><p>ที่จริงแล้วพี่ thread pool มีชื่อเรียกอีกชื่อคือ libuv ครับผมขอยังไม่พูดถึง libuv ก็แล้วกันนะครับเพราะเรื่องมันเยอะมากกกก(ที่จริงขี้เกียจอ่าน) โดยพี่ thread pool ของเราเอาไว้รับมือกับการทำงานที่เป็น blocking I/O ครับ โดยการทำงานของมันก็ง่ายแสนง่าย ก็คือมันจะทำการเช็คแต่ละ request มาเป็น Blocking I/O รึเปล่าถ้าเป็นก็ให้ส่ง request นั้นไปทำงานโดยมี thread pool เป็นตัวจัดการแทน event loop แต่เอ๊ะทำไมเรายังต้องใช้ thread pool อยู่แค่ event loop ก็น่าจะจัดการได้แล้วนี้น๊า แต่...มันผิดเลยครับเพราะตัว event loop จะ process อะไรที่ทำงานแป๊บเดียวก็เสร็จไม่เสียนานมากๆ แต่ถ้ามี request ที่ต้องใช้เวลานานมากๆล่ะอย่างเช่น การทำงานกับ file system หรือติดต่อ database ที่ใช้เวลานานๆ ตัว event loop เริ่มจะเป็นคอขวดแล้วใช่มั๊ยล่ะครับ นี้ถึงเป็นเหตุผลทำไมถึงมี thread pool และทำไม database driver ที่เราชอบใช้กันมันถึงเป็น callback,promise ครับ</p><p>เข้าเรื่อง thread pool ที่แท้ true กันครับ เริ่ม~~~ การทำงานของมันก็ตามรูปที่ผมวาดไว้เลยครับโดนการทำงานก็คือเช็ค request ว่าเป็น Blocking I/O รึเปล่าถ้าเป็นก็ไปเช็คว่าข้างในมี thread pool เหลือให้ใช้รึเปล่าโดยปรกติแล้วจะมีแค่ 4 ตัวเท่านั้นแต่เราสามารถเพิ่มได้โดยใช้คำสั่ง <strong><em>UV_THREADPOOL_SIZE=5</em></strong> ได้เลยครับ หรือจะใช้ <strong><em>process.env.UV_THREADPOOL_SIZE = 10</em></strong> ก็ได้ครับ จะได้เพิ่มช่องสำหรับจัดการกับ Blocking I/O ที่จะเกิดขึ้นครับ</p><h4 id="-">เสริม</h4><p>พยายามหลีกเลี่ยงการใช้งาน function ที่เป็นแบบ Blocking I/O ให้ได้ครับเพราะว่าจะไปทำงานอยู่บน thread pool มากเกินไปอย่างเช่น</p><p><code>fs.fsyncSync(fd)</code><br><br><br><code>fs.lchmodSync(path, mode)</code></p><p>ก็จบกันแล้วนะครับสำหรับ Event loop ตอนสุดท้ายแบบพื้นฐานมากๆนะครับ</p><p>ผมเกือบลืมเลย ปุกาศๆ  ถ้าเราอีกสักหน่อยไม่น่าจะเกิน 10 ปีนี้ เดี๋ยวๆไม่ใช่สิ ไม่เกิน 2 เดือนข้างหน้าพวกเราอยากจะทำคลิปสอน NodeJS แบบฟรีๆ ไม่กั๊กอะไรทั้งนั้นแต่ถ้าใครบริจาคก็ได้ครับ แต่ที่สำคัญคือฟรี!!!!</p><p>Ref:</p><p><a href="https://en.wikipedia.org/wiki/Reactor_pattern">Reactor pattern</a></p><p><a href="https://www.journaldev.com/7462/node-js-architecture-single-threaded-event-loop">Single Threaded Event Loop</a></p><p><a href="https://nodejs.org/en/docs/guides/blocking-vs-non-blocking/">Blocking vs Non-Blocking</a></p><p><a href="https://www.future-processing.pl/blog/on-problems-with-threads-in-node-js/">On problems with threads in node.js</a></p>]]></content:encoded></item><item><title><![CDATA[Event-loop แบบพื้นฐานมากกกกก #1]]></title><description><![CDATA[อยู่ดีก็ผมก็อยากจะเขียนเรื่อง event loop ใน NodeJS ขึ้นมาแต่ต้องขอโทษด้วยครับเพราะเนื้อหามันเยอะมากก เลยต้องตัดแบ่งนะครับ]]></description><link>https://lagmanzaza.github.io//event-loop-1/</link><guid isPermaLink="false">5dac142e79778f6fa0d0be9a</guid><category><![CDATA[NodeJS]]></category><dc:creator><![CDATA[tar jarupong]]></dc:creator><pubDate>Sun, 20 Oct 2019 08:04:37 GMT</pubDate><media:content url="https://lagmanzaza.github.io//content/images/2019/10/GSBai6R.png" medium="image"/><content:encoded><![CDATA[<img src="https://lagmanzaza.github.io//content/images/2019/10/GSBai6R.png" alt="Event-loop แบบพื้นฐานมากกกกก #1"><p>สวัสดีครับผมกลับมาพบกับต้าคนเดิมคนดีอีกเช่นเคยนะครับ ซึ่งวันนี้ผมจะมาเล่าเรื่อง Event-loop ใน NodeJS ในภาษาและรูปภาพที่ทุกคนเข้าใจกันมาจะรอช้าอยู่ทำไมเข้าเรื่องกันเลย เดี๋ยวก่อนสิ ถ้าสำหรับใครที่ยังไม่ได้อ่านเรื่อง execution stack แนะนำให้กลับไปอ่านก่อนนะครับ <a href="https://krapokecode.github.io/BlogPost/exec-context-stack">link</a> จะได้เข้าใจมากขึ้น มาเข้าเรื่องกันเลยครับ</p><h4 id="event-loop">Event loop</h4><p>คือการทำงานใน NodeJS เป็นแบบ Single-thread แล้วตัว single thread คืออะไร มาเริ่มที่ single thread กันก่อนนะครับ เริ่ม~~~</p><figure class="kg-card kg-image-card"><img src="https://i.imgur.com/sxoUOEC.png" class="kg-image" alt="Event-loop แบบพื้นฐานมากกกกก #1"></figure><p>ตรงนี้ทุกคนคนจะเห็นว่าในหนึ่ง process มันมีอยู่หนึ่ง thread ครับแต่ในความเป็นจริงแล้ว process สามารถมีได้หลายๆ thread โดยแต่ละตัวจะกระจายกันทำงานคนละแบบหรือทำงานแบบเดียวกันก็ได้ ทั้งหมดนี้คือ process &amp; thread แบบพื้นฐานสุดๆ ได้เวลากลับมาเข้าเรื่องหลักกันครับ เรื่องของเรื่องก็คือ Event-loop มันทำงานอยู่แค่ thread เดียวครับ รูปภาพก็จะประมาณนี้ครับ</p><pre><code>
// Event loop
   ┌───────────────────────────┐
┌─&gt;│           timers          │
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
│  │     pending callbacks     │
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
│  │       idle, prepare       │
│  └─────────────┬─────────────┘      ┌───────────────┐
│  ┌─────────────┴─────────────┐      │   incoming:   │
│  │           poll            │&lt;─────┤  connections, │
│  └─────────────┬─────────────┘      │   data, etc.  │
│  ┌─────────────┴─────────────┐      └───────────────┘
│  │           check           │
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
└──┤      close callbacks      │
   └───────────────────────────┘
   
   
</code></pre><p>ผมต้องขอบอกก่อนว่าตัว NodeJS จะทำงานเป็นแบบคิววิ่งวนไปเรื่อยๆเพื่อเช็คว่ามีอะไรที่ต้องประมวลผลอีกรึเปล่า ประมาณนี้ครับ งั้นก็มาพูดถึงแต่ละตัวกันเลยครับ</p><p><strong>Timers</strong></p><p>เป็นสิ่งแรกในการทำงานของ event loop สำหรับจัดการเป็นส่วนสำหรับเรียกใช้งาน function ที่เป็น callback เช่น <em>setTimeout()</em> , <em>setInterval()</em> เป็นต้น</p><p><strong>Pending Callback</strong></p><p>สำหรับจัดการเมื่อ callback ทำงานเสร็จสิ้นหรือ error ครับ</p><p><strong>Poll</strong></p><p>ตัว poll เป็นตัวรอรับ request หรือ I/O event อันใหม่</p><p><strong>idle, prepare</strong></p><p>จะทำงานส่วนอยู่ใต้ลงไปอีก ผมขอพูดถึงบทบทความหน้าครับ ^^</p><p><strong>check</strong></p><p>ตรงจุดนี้ใช้สำหรับประมวลผล <em>setImmediate()</em> ได้ครับ</p><p><strong>Close callback</strong></p><p>ตามชื่อเลยครับ สำหรับปิด callback หรือ event ต่างๆ</p><p>ต้องขอตัดจบแบบละครไทยด้วยนะครับในบทความหน้าผมสัญญาว่าจะมาเล่าให้ละเอียดกว่านี้เพื่อให้ทุกคนเข้าใจมากขึ้นครับ</p><p>ปล. ที่จริงมีเรื่อง Event-multiplexer, mico task blah blah ที่ผมยังไม่ได้พูดอีก เศร้า</p>]]></content:encoded></item><item><title><![CDATA[Hoisting ใน Javascript คืออะไร]]></title><description><![CDATA[ท่านใดที่เขียน Javascript จะรู้ดีว่าถ้าใครใช้ var มันจะเกิด Hoisting เสมอ ผมเลยจะมาอธิบายว่า hoisting คืออะไร ทำงานยังไงกัน]]></description><link>https://lagmanzaza.github.io//hoisting-javascript/</link><guid isPermaLink="false">5dac2d87c479810291b1a0f7</guid><dc:creator><![CDATA[tar jarupong]]></dc:creator><pubDate>Wed, 20 Feb 2019 09:48:00 GMT</pubDate><media:content url="https://lagmanzaza.github.io//content/images/2019/10/GYwt6rf.png" medium="image"/><content:encoded><![CDATA[<img src="https://lagmanzaza.github.io//content/images/2019/10/GYwt6rf.png" alt="Hoisting ใน Javascript คืออะไร"><p>สำหรับใครที่เคยชินกับ var มาแล้วคงเข้าใจอยู่แล้วว่ามี let &amp; const ที่มาแทนที่รุ่นพี่ไปแล้วเพราะว่า 2 ตัวนี้แก้ปัญหาหาเรื่อง hoisting แต่ๆ ส่วนใหญ่แล้วเราเคยได้ยินอย่างว่า<br><br></p><p>อย่าไปใช้ var นะเพราะมันให้เกิด hoisting</p><p><br>แล้วอะไรคือ hoisting กันล่ะวันนี้ผมจะมาอธิบายให้ฟังกันครับ เริ่ม~~~ <br></p><h3 id="hoisting">Hoisting ?</h3><p>hoisting คือการประกาศตัวแปรแต่ยังไม่มีการกำหนดค่าเข้าไป และอุ้มตัวแปรไปอยู่บนสุดครับ</p><pre><code>
console.log(a);
var a = 'สวัสดีครับ';
  
</code></pre><p>ถ้าเป็นภาษาอื่นมันคง error ว่าไม่ได้มีการประกาศตัวแปร a โว้ยไปประกาศส่ะ แต่!ใน JS ก็เกิดขึ้นได้ถ้ามีปาปิก้า มันจะขึ้นว่า <strong><em>undefined</em></strong> แทน... เอ้าเป็นไปได้ไงมันต้อง error สิฟ๊ะ ตอนนี้ทุกคนกำลังงงว่ามันเกิดขึ้น มันมีชื่อเรียกว่า lexical environment ครับ...</p><p><br></p><h3 id="lexical-environment">Lexical environment ?</h3><p>ผมเดาว่าเป็นคำที่ทุกคนไม่คุ้นหูแน่ๆเลย แต่เอาเป็นว่าช่างมันเถอะครับ ก่อนอื่นผมของเรียกมันว่าเจ้า lex ก็แล้วกันนะครับจะได้คุ้นหูกัน ผมจะอธิบายว่าเจ้านี้อะไรไว้ทำอะไร สำคัญยังไง<br><br></p><ol><li>คือ ? ==&gt; มันคือกล่องใบนึงครับที่เอาไว้เก็บ variable, function ที่จะเอาไปใช้งานใน software ของเราครับ</li></ol><pre><code>
LexicalEnvironment = {
  Identifier:  &lt;value&gt;,
  Identifier:  &lt;function object&gt;
}

</code></pre><p>รูปแบบมันก็จะประมาณนี้ครับ เมื่อใดก็ตามที่เรามีการตัวแปร <strong><em>var a = 'name'</em></strong> อย่างนี้ตัวเจ้า lex จะเป็นอย่างนี้</p><pre><code>
LexicalEnvironment = {
  a:  'name',
}

</code></pre><p>จะเห็นว่ามีการกำหนดค่าให้ a ลงไปประมาณนี้ครับ</p><ol><li>ปัญหา ? ==&gt; แล้วเจ้า lex มันจะมีปัญหาคืออะไรก็ปรกติดี ในความปรกติมีความไม่ปรกคือ ถ้าสมมุติว่าทำแบบนี้ล่ะ</li></ol><pre><code>
  var a;
  console.log(a);
  a = "Tar";

</code></pre><p>จะเห็นว่าประกาศตัวแปรแต่ไม่ได้กำหนดค่าไปแล้วแสดงข้อความออกไปเลย มันต้อง error แน่ๆเลย แต่!! ต้องกันข้ามเลยมันจะไม่ error แต่จะเป็น <strong>undefined</strong> ดังนั้นตัวเจ้า lex จะเป็นแบบนี้คือการที่เจ้า lex เนี๊ยจะทำการกำหนดค่าให้ตัวแปรกที่ประกาศไปแล้วแต่ยังไม่กำหนดค่าให้เป็น <strong>undefined</strong> ไว่ก่อน</p><pre><code>
LexicalEnvironment = {
  a: undefined,
}

</code></pre><p>แล้วมันถึงไปกำหนดค่าไปหลังจาก <strong>console.log(a)</strong></p><pre><code>
LexicalEnvironment = {
  a: 'Tar',
}

</code></pre><p>นี้ก็คือการทำงานที่เรียกกันว่า <strong>Hoisting</strong> ครับ<br><br></p><h3 id="-let-const-">ใช้ let &amp; const กันกว่า</h3><p>ก็ไปใช้ let &amp; const แทนการใช้ var กันเถ๊อะ!!!!</p><p>คงนี้ไม่พ้นกับการใช้ let &amp; const แต่หารู้ไม่ว่าเจ้าสองตัวนี้ก็ไม่ต่างจาก var มามันไม่ได้หนีไปจากเจ้า lex เลยแต่แค่เปลี่ยนค่ามันแค่นั้นเองแทนที่จะเป็น undefined ก็เป็น uninitialized แทน งั้นผมยกตัวอย่างดีกว่า</p><pre><code>
  let a;
  console.log(a);
  a = "Tar";

</code></pre><p>ตรงตัวแปร a เจ้า lex จะเป็นแบบนี้แทน</p><pre><code>
LexicalEnvironment = {
  a: &lt;uninitialized&gt;
}

</code></pre><p>ทุกคนเห็นไว้ว่ามัน make sense กว่าแทนที่จะ undefined ส๊ะอีกนะครับ เย้!! ในที่สุดผมก็เขียนเส็จสักทีครับ สำหรับใครอยากเห็นตัวอย่างมากขึ้นไปอ่านที่ devhoy ได้เลยครับผมทิ้งไว้ข้างล่างให้นะครับ สวัสดีครับ</p><p>ปล. ที่จริงมันมีเรื่อง Execution Context และ Execution Stack อีกถ้าผมไม่ลืมผมจะมาอธิบายนะครับ ขอไปให้อ่านให้เข้าใจก่อน</p><p>Ref:</p><p><a href="https://blog.bitsrc.io/hoisting-in-modern-javascript-let-const-and-var-b290405adfda">Hoisting in Modern JavaScript</a></p><p><a>DevAhoy - hoisting</a></p>]]></content:encoded></item><item><title><![CDATA[Execution context and Execution Stack in javascript]]></title><description><![CDATA[ใครที่เขียน Javascript แล้วไม่รู้จัก 2 ตัวนี้ต้องอ่านเลยครับ ผมพยายามอธิบายให้เข้าใจง่ายที่สุดดดดดด]]></description><link>https://lagmanzaza.github.io//execution-context-and-execution-stack-in-javascript/</link><guid isPermaLink="false">5dac2cf0c479810291b1a0eb</guid><dc:creator><![CDATA[tar jarupong]]></dc:creator><pubDate>Thu, 14 Feb 2019 09:45:00 GMT</pubDate><media:content url="https://lagmanzaza.github.io//content/images/2019/10/iX19pbS.png" medium="image"/><content:encoded><![CDATA[<img src="https://lagmanzaza.github.io//content/images/2019/10/iX19pbS.png" alt="Execution context and Execution Stack in javascript"><p>ไหนๆวันนี้ก็เป็นวันวาเลนไทน์ของใครหลายๆคนแล้วแต่สำหรับผมมันก็แค่วันพฤหัสบดีที่แสนธรรมดา... เอาเวลาที่อิจฉาคนมีคู่มาเขียนบทความดีกว่า =__+'<br>สวัสดีครับกลับมาผมกับผมต้าคนเดิมคนดี วันนี้ผมรู้สึกคึ้กไปอ่านเรื่อง execution context กับ execution stack มาครับก็เลยมาเล่าให้ฟังครับ เริ่ม~~~</p><p>ขอเกริ่นก่อนว่ามันคือ Stack ใน data structure นั้นเองครับทีนี้มาเข้าเรื่องกันเลยดีกว่า</p><h4 id="execution-context">Execution Context</h4><p>มันคือสภาพแวดล้อมสำหรับ Javascript ครับ สำหรับ running process ทั้งหมดโดยตัว execution context จะถูกแบ่งออกเป็น 3 ตัวครับ ตามนี้เลย</p><p><br></p><p><strong>Global</strong> =&gt; เหมือนกับก้อน object ใหญ่ๆที่เก็บ function สำคัญๆเอาไว้ ถ้านึกไม่ออกก็คือมันคือ <em>window</em> หรือ <em>this</em> ใน javascript นั้นแหล่ะครับ</p><p><strong>Functional</strong> =&gt; มันจะถูกสร้างเมื่อมีการเรียกใช้ function ครับ</p><p><strong>Eval</strong> =&gt; ตัวนี้จะถูกสร้างก็ต้องเมื่อเรียกใช้ <em>eval()</em></p><p><br>ตอนนี้ทุกคนก็พอรู้จัก execution context ในรูปแบบต่างๆแล้วนะครับ มาต่อกันที่ execution stack กันเลย 1 2 ฮึ้บ...</p><p><br></p><h4 id="execution-stack">Execution Stack</h4><p>ก่อนอื่นผมขออธิบายคร่าวๆเรื่อง stack ก่อนนะครับซึ่ง stack มันมี operation 2 อันคือ push กับ pop ซึ่งเป็นโครงสร้างการเก็บข้อมูลแบบนึงที่เป็นการทำงานแบบ LIFO(last in first) คือการเข้าทีหลังออกก่อนนั้นเอง ถ้าทุกคนยังไม่เข้าใจอยู่ ปริ้งภาพมา~~~</p><figure class="kg-card kg-image-card"><img src="https://i.imgur.com/S38kijr.png" class="kg-image" alt="Execution context and Execution Stack in javascript"></figure><p>แค่รูปนี้ทุกคนคงเข้าใจกันแล้ว ง่ายๆเลยคือ push คือการเพิ่มข้อมูลไว้บนสุดส่วนเจ้า pop คือการเอาข้อมูลที่อยู่บนสุดออกไปครับ ตัว Execution stack คือการที่เราเอาการเรียก function ไปเก็บลง stack นั้นเองครับเพื่อรอให้เจ้านายเรียกไปใช้งานนั้นเอง มันเป็นทำนองคลองเดียวกันเลยครับ ลองมาดูโค๊ดตัวอย่างพร้อมรูปภาพการทำงานกันเลยครับ</p><pre><code>let a = 5;
let b = 10
function add(x,y){
  return x + y;
}

const c = add(a,b);

</code></pre><figure class="kg-card kg-image-card"><img src="https://i.imgur.com/G02Mdah.png" class="kg-image" alt="Execution context and Execution Stack in javascript"></figure><p><br>ทุกคนจะเห็นว่าตัว <em>add()</em> จะถูกเก็บลง call stack ก่อนเพื่อรอเจ้านาย(Global execution) เรียกใช้งานหลังจากนั้น <em>add()</em> ก็ถูกเรียกใช้ครับ เอ๊ะ! ผมลืมบอกว่า function, variable จะถูกเก็บลง global memory ไว้ก่อนนะครับ มาต่อที่ภาพที่สองกันเลย</p><figure class="kg-card kg-image-card"><img src="https://i.imgur.com/5V0G5e4.png" class="kg-image" alt="Execution context and Execution Stack in javascript"></figure><p><br>หลังจากที่ตัว global execution ได้ทำการใช้งานทาส <em>add()</em> เป็นที่สำเร็จเสร็จสิ้นแล้ว พี่ global ส่งผลลัพธ์ไปเก็บที่ตัวแปร <em>C</em> ใน global memory เพื่อใช้งานต่อไป</p><p>ก็จบไปแล้วสำหรับบทความนี้ถ้าใครค้างคาใจกับมาเรื่องก็มาคุยกับพวกเราได้ที่ Fanpage ได้นะครับ สำหรับวันนี้ก็ของลาไปก่อน สวัสดีวันวาเลนไทน์ครับ</p><p>Ref:</p><p><a href="https://blog.bitsrc.io/understanding-execution-context-and-execution-stack-in-javascript-1c9ea8642dd0">Execution context and stack</a></p><p><a href="https://www.valentinog.com/blog/js-execution-context-call-stack/">What Is The Execution Context?</a></p>]]></content:encoded></item><item><title><![CDATA[Pipe function ใน Javascript]]></title><description><![CDATA[ท่านใดเคยประสบปัญหาเรื่องการใช้ transformation function เยอะๆรึเปล่า ผมมีทางแก้มาทำเสนอ]]></description><link>https://lagmanzaza.github.io//pipe-function-ain-javascript/</link><guid isPermaLink="false">5dac2df0c479810291b1a101</guid><dc:creator><![CDATA[tar jarupong]]></dc:creator><pubDate>Sun, 10 Feb 2019 09:50:00 GMT</pubDate><media:content url="https://lagmanzaza.github.io//content/images/2019/10/fp0HTAi.jpg" medium="image"/><content:encoded><![CDATA[<img src="https://lagmanzaza.github.io//content/images/2019/10/fp0HTAi.jpg" alt="Pipe function ใน Javascript"><p>สำหรับใครที่เคยใช้เจ้าแพะหรือ ramdaJS มาก่อนคงได้ยินหรือเคยใช้ pipe() มาอยู่แล้ว ซึ่งพี่ pipe() เอาไว้ทำอะไรน่ะเหรอ ดูตัวอย่างเลยครับ</p><pre><code>getFirstChar( toLowerCase(data))

</code></pre><p>ทุกเห็นคงคิดว่าก็ไม่เห็นมีไรเลยซับซ้อนตรงไหนแค่ 2 functions เอง แต่ถ้าสมมุติเป็นแบบนี้ล่ะ</p><pre><code>getFirstChar( toLowerCase(convertAsciiToText(getName(data))))
</code></pre><figure class="kg-card kg-image-card"><img src="https://firebasestorage.googleapis.com/v0/b/myblog-7f48d.appspot.com/o/flamelink%2Fmedia%2F1545679658057_1545660065385_holy-shit-what-dc0kau.jpg?alt=media&amp;token=494d24a5-5bba-42fc-a2c0-6fa7b851a73f" class="kg-image" alt="Pipe function ใน Javascript"></figure><p>เฮ๊~~~~~~ ทุกคนกำลังคิดแบบนี้อยู่แน่ๆ</p><p>ก่อนที่เราจะมาพูดถึงวิธีการแก้ไขปัญหา เรามาพูดถึงแนวคิดของเจ้า pipe กันก่อน ต้องย้อนกลับไปความรู้ทางคณิตศาสตร์ตอน ม. 5 การเลยคือเรื่อง relation and function ต้องขอบอกก่อนว่าผมก็ไม่เก่งคณิตศาสตร์แต่ผมจะพยายามอธิบายให้ง่ายที่สุดเท่าที่จะทำได้นะครับ</p><p><strong>Math #1 basic function</strong></p><p>สมมุติว่าผมสร้าง function ตัวนึงสำหรับรับค่า x เพื่อนำไปบวก 2</p><pre><code>f(x) = x + 2
</code></pre><p>ทีนี้ผมสร้างอีก function นึงสำหรับรับค่า x แล้วทำไปคูณ 5</p><pre><code>g(x) = x * 5
</code></pre><p>เริ่มจาก function แรกก่อน</p><pre><code>f(2) = 2 + 2
     = 4
</code></pre><p>ต่อมาตัวก็เป็น function g</p><pre><code>g(2) = 2 * 5 
     = 10
</code></pre><p>นี้ก็เป็นตัวอย่างเล็กๆน้อยจากเรื่อง function สำหรับ ม. 5 ต่อไปมาเริ่มในสิ่งที่ยากขึ้นอีกระดับนึงเรียกว่า composite function เริ่ม!!</p><p><strong>Math #2 Composite function</strong></p><p>ง่ายๆมันคือการรวม function เข้าด้วยกันนั้นเอง ผมขอยก 2 functions ด้านบนมาด้วยนะครับจะได้ไม่เสียเวลา มันก็จะได้แบบนี้</p><p>อันดับแรกผมเอา 2 function2 นี้รวมกัน</p><pre><code>f(g(x))
</code></pre><p>ผมจะเขียนแนวการคิดไปทีละขั้นตอนเน้อ...</p><pre><code>f(g(x)) = f(x * 5)  
        = (x * 5) + 2
</code></pre><p>ลองมาดูตัวอย่างกัน</p><pre><code>f(g(2)) = f(2 * 5)  
        = (2 * 5) + 2  
        = 10 + 2  
        = 12
</code></pre><p>เอ๊ะแล้วเจ้า pipe() สุดที่รักของเรามันเกี่ยวอะไรกับคณิตศาสตร์ชวนปวดหัว ผมต้องบอกเลยว่ามันคืออันเดียวกัน ผมจะเปรียบเทียบให้ดู</p><pre><code>f(g(x)) = getFirstChar( toLowerCase(data))
</code></pre><p>เห็นมั๊ยว่าเหมือนกันเป๊ะๆ เรามาดูโค๊ด pipe() กันเลย</p><pre><code>const pipe = (...fns) =&gt; x =&gt; fns.reduce((v, f) =&gt; f(v), x)
</code></pre><p>สำหรับใครที่ไม่รู้จัก <a href="https://medium.freecodecamp.org/how-do-javascript-rest-parameters-actually-work-227726e16cc8"><strong>rest parameter</strong></a> กับ <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce"><strong>reduce</strong></a>ตามนี้โล๊ด</p><p>วิธีการใช้ตัว pipe() ก็ตามนี้เลย</p><p>pipe(getFirstChar, toLowerCase, convertAsciiToText, getName)(data)</p><p>เห็นมั๊ยว่าสะดวกและอ่านงานกว่าเยอะ ถือว่าเป็นวิธีที่ดีมากๆ</p><p>เป็นไงบ้างครับ สำหรับอะไรแบบนี้</p><p>Ref:</p><p><a href="https://medium.com/front-end-weekly/pipe-and-compose-in-javascript-5b04004ac937">https://medium.com/front-end-weekly/pipe-and-compose-in-javascript-5b04004ac937</a></p><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters</a></p>]]></content:encoded></item></channel></rss>